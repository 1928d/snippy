#!/usr/bin/env perl
use strict;
use warnings;
use FindBin;
use Time::Piece;
use Time::Seconds;
use File::Path qw(make_path remove_tree);
use File::Spec;
use Bio::SeqIO;
use Bio::Tools::GFF;

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# global variables

my $EXE = $FindBin::RealScript;
my $BINDIR = $FindBin::Bin;
my $VERSION = "1.6-alpha";
my $SYNOPSIS = "fast bacterial variant calling from NGS reads";
my $AUTHOR = 'Torsten Seemann <torsten.seemann@gmail.com>';
my $URL = 'https://github.com/Victorian-Bioinformatics-Consortium/snippy';
my $OPSYS = $^O;
my $t0 = localtime;

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# command line options

my(@Options, $quiet, $force, $outdir, $prefix, $reference, $threads, $report,
             $mapqual, $mincov, $minfrac, $rgid, $bwaopt,
             $interleaved, $noindels, $cleanup);
setOptions();

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# greet the user

msg("This is $EXE $VERSION");
msg("Written by $AUTHOR");
msg("Obtained from $URL");
msg("Detected operating system: $OPSYS");

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# give access to bundled tools (at end of PATH)

msg("Enabling bundled $OPSYS tools.");
$ENV{PATH} = "$BINDIR:"
             .$ENV{PATH}
             .":$BINDIR:$BINDIR/../binaries/$OPSYS"
             .":$BINDIR/../binaries/noarch";

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# check for needed exes

for my $exe (qw(cp rm awk renice bwa samtools tabix bgzip
                parallel freebayes freebayes-parallel fasta_generate_regions.py 
                vcffilter vcfstreamsort vcfuniq vcffirstheader vcf-consensus
                snippy-vcf_tsv snippy-vcf_report)) {
  system("which $exe > /dev/null")==0 or err("Can not find '$exe' in PATH");
  msg("Found $exe - ok.");
}

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# type check parameters

$prefix =~ m{/} and err("File --prefix can not have slash '/' in it.");

$reference or err("Please supply a reference FASTA file with --reference");
-r $reference or err("Invalid --reference filename");
$reference = File::Spec->rel2abs($reference);
msg("Using reference: $reference");

$threads > 0 or err("Invalid --threads $threads");
msg("Will use $threads threads");

my $refsize = -s $reference; # rough size in bases
my $refchunksize = int( $refsize / $threads / 2 );
msg("Reference is approximately $refsize bp, will chunk into $refchunksize bp.");

@ARGV = map { File::Spec->rel2abs($_) } @ARGV;
my @reads = shift @ARGV;
push @reads, shift(@ARGV) if @ARGV;
msg("Using reads: @reads");
for my $readfn (@reads) {
  -r $readfn or err("Can't read sequence file: $readfn");
}

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# prepare output folder

$outdir or err("Please specify where to write results to using --outdir folder");
if (-d $outdir) {
  if ($force) {
    msg("Deleting all files in existing folder: $outdir");
    remove_tree($outdir, { keep_root=>1 } )
  }
  else {
    err("Output folder $outdir already exists.");
  }
}
else {
  msg("Creating folder: $outdir");
  make_path($outdir);
}
chdir($outdir);

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# load the reference, now support all formats Bioperl can load

msg("Extracting FASTA and GFF from reference...");
my $in = Bio::SeqIO->new(-file=>$reference) or err("Could not guess file format: $reference");
my $out = Bio::SeqIO->new(-file=>">ref.fa", -format=>'fasta');
my $gff = Bio::Tools::GFF->new(-file=>">ref.gff", -gff_version=>3);
my $nseq = 0;
my $nfeat = 0;
while (my $seq = $in->next_seq) {
  $out->write_seq($seq);
  $nseq++;
  for my $f ($seq->get_SeqFeatures) {
    next if $f->primary_tag =~ m/^(source|misc_feature|gene)$/;
    $f->source_tag($EXE);
    if ($f->has_tag('locus_tag')) {
      my($id) = $f->get_tag_values('locus_tag');
      $f->add_tag_value('ID', $id);
    }
    $gff->write_feature($f);
    $nfeat++;
  }
}
msg("Wrote $nseq sequences to ref.fa");
msg("Wrote $nfeat features to ref.gff");

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# prepare the command options

$rgid ||= $prefix;
msg("Using BAM RG (Read Group) ID: $rgid");

$bwaopt .= qq{ -v 2 -M -R '\@RG\tID:$rgid\tSM:$rgid'};
$bwaopt .= ' -p' if $interleaved;

my $tsvopt = $noindels ? '--noindels' : '';

#my $fbopt = "-p 1 -q 20 -m $mapqual -F $minfrac -C $mincov -V";
my $fbopt = "-p 1 -q 20";
my $mincov2 = $mincov-1;

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# prepare the commands

my @cmd = (
  "samtools faidx ref.fa",
  "bwa index ref.fa",
  "(bwa mem $bwaopt -t $threads ref.fa @reads"
    ." | samtools view -@ $threads -q $mapqual -F 3844 -S -b -u -T ref.fa -"
    ." | samtools sort -@ $threads - $prefix)",
  "samtools index $prefix.bam",
  "fasta_generate_regions.py ref.fa.fai $refchunksize > regions.txt",
  "freebayes-parallel regions.txt $threads $fbopt -f ref.fa $prefix.bam > $prefix.raw.vcf",
  "vcffilter -f 'DP > $mincov2' -f 'QUAL > 10' $prefix.raw.vcf > $prefix.vcf",
  "bgzip -c $prefix.vcf > $prefix.vcf.gz",
  "tabix -p vcf $prefix.vcf.gz",
  "$BINDIR/snippy-vcf_tsv --bam $prefix.bam --gff ref.gff --ref ref.fa --vcf $prefix.vcf > $prefix.csv",
  "vcf-consensus $prefix.vcf.gz < ref.fa > $prefix.consensus.fa",
);

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# run the commands

my $log_file = "$prefix.log";

for my $cmd (@cmd) {
  # put section in logfile
  open my $logfh, '>>', $log_file;
  print $logfh "\n### ", $cmd, "\n\n";
  close $logfh;
  # run it
  $cmd .= " 2>> $log_file";
  msg("Running: $cmd");
  system($cmd)==0 or err("Error running command, check $outdir/$log_file");
}

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# produce .bed and .gff files from the .csv

open BED, '>', "$prefix.bed";

open GFF, '>', "$prefix.gff";
print GFF "##gff-version 3\n";

msg("Creating BED and GFF files.");
my $num_snps=0;
open CSV, '<', "$prefix.csv";
while (<CSV>) {
  chomp;
  my($chr,$pos,$type,$ref,$alt,$evid) = split m/\t/;
  next if $pos !~ m/^\d+$/;  # header line or other gumpf
  print BED join("\t", $chr, $pos-1, $pos),"\n";
  print GFF join("\t", $chr, "$EXE:$VERSION", 'variation', $pos, $pos, 
                       '.', '.', 0, "note=$type $ref=>$alt $evid"),"\n";
  $num_snps++;
}
msg("Identified $num_snps variants.");

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# optionally generate a long visual report

if ($report) {
  msg("Generating report, please be patient...");
  system("$BINDIR/snippy-vcf_report --bam $prefix.bam --ref ref.fa --vcf $prefix.vcf > $prefix.txt 2>> $log_file");
}

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# clean up

if ($cleanup) {
  my @delme = map { "ref.fa$_" } ('', qw(.fai .amb .ann .bwt .pac .sa));
  push @delme, ("$prefix.bam", "$prefix.bam.bai", "$prefix.raw.vcf");
  for my $file (@delme) {
    msg("Deleting: $file");
    unlink $file;
  }
}

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# calculate time spent

my $t1 = localtime;
my $secs = $t1 - $t0; # returns a Time::Seconds
msg("Walltime used:", $secs->pretty);

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# report results

my($outfiles) = qx(echo $prefix.*);
chomp $outfiles;
msg("Result folder: $outdir");
msg("Result files: $outfiles");

msg("May the SNPs be with you.");

#----------------------------------------------------------------------

sub msg {
  return if $quiet;
  my $t = localtime;
  my $line = "[".$t->hms."] @_\n";
  print STDERR $line;
}

#----------------------------------------------------------------------

sub err {
  $quiet=0;
  msg(@_);
  exit(2);
}

#----------------------------------------------------------------------

sub version {
  print STDERR "$EXE $VERSION\n";
  exit;
}

#----------------------------------------------------------------------

sub show_citation {
  print STDERR << "EOCITE";
  
If you use $EXE in your work, please cite:

    Seemann T (2015)
    $EXE: $SYNOPSIS
    $URL
    
Thank you.

EOCITE

  exit;
}

#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    'Options:',
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"version", VAR=>\&version,           DESC=>"Print version and exit"},
    {OPT=>"citation",VAR=>\&show_citation,     DESC=>"Print citation for referencing $EXE"},
    {OPT=>"quiet!",  VAR=>\$quiet, DEFAULT=>0, DESC=>"No screen output"},
    {OPT=>"threads=i",  VAR=>\$threads, DEFAULT=>8,  DESC=>"Number of threads for bwa/samtools"},
    {OPT=>"reference=s",  VAR=>\$reference, DEFAULT=>'',  DESC=>"Reference genome. Supports FASTA, GenBank, EMBL (not GFF)"},
    {OPT=>"outdir=s",  VAR=>\$outdir, DEFAULT=>'',  DESC=>"Output folder"},
    {OPT=>"prefix=s",  VAR=>\$prefix, DEFAULT=>'snps',  DESC=>"Prefix for output files"},
    {OPT=>"force!",  VAR=>\$force, DEFAULT=>0,  DESC=>"Force overwrite of existing output folder"},
    {OPT=>"interleaved!",  VAR=>\$interleaved, DEFAULT=>0,  DESC=>"Single input file is interleaved pairs, not singles"},
    {OPT=>"noindels!",  VAR=>\$noindels, DEFAULT=>0,  DESC=>"Only look for substitutions, not indels"},
    {OPT=>"mapqual=f",  VAR=>\$mapqual, DEFAULT=>60,  DESC=>"Minimum mapping quality to allow"},
    {OPT=>"mincov=i",  VAR=>\$mincov, DEFAULT=>10,  DESC=>"Minimum coverage of variant site"},
    {OPT=>"minfrac=f",  VAR=>\$minfrac, DEFAULT=>0.9,  DESC=>"Minumum proportion for variant evidence"},
    {OPT=>"cleanup!",  VAR=>\$cleanup, DEFAULT=>0,  DESC=>"Remove all non-SNP files: BAMs, indices etc"},
    {OPT=>"rgid=s",  VAR=>\$rgid, DEFAULT=>'',  DESC=>"Use this \@RG ID: in the BAM header"},
    {OPT=>"bwaopt=s",  VAR=>\$bwaopt, DEFAULT=>'',  DESC=>"Extra BWA MEM options, eg. -x pacbio"},
    {OPT=>"report!",  VAR=>\$report, DEFAULT=>0,  DESC=>"Produce long report with visual alignment (slow)"},
  );

  (!@ARGV) && (usage());

  &GetOptions(map {$_->{OPT}, $_->{VAR}} grep { ref } @Options) || usage();

  # Now setup default values.
  foreach (@Options) {
    if (ref $_ && defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

#----------------------------------------------------------------------

sub usage {
  print STDERR "Synopsis:\n  $EXE $VERSION - $SYNOPSIS\n",
               "Author:\n  $AUTHOR\n",
               "Usage:\n",  
               "  $EXE [options] --ref <ref> <R1.fq.gz> <R2.fq.gz>\n",
               "  $EXE [options] --ref <ref> --interleaved <shuffledPairs.fq>\n",
               "  $EXE [options] --ref <ref> <SE.fasta>\n",
               "";

  foreach (@Options) {
    if (ref) {
      my $def = defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
      $def = ($def ? ' (default OFF)' : '(default ON)') if $_->{OPT} =~ m/!$/;
      my $opt = $_->{OPT};
      $opt =~ s/!$//; 
      $opt =~ s/=s$/ [X]/; 
      $opt =~ s/=i$/ [N]/;
      $opt =~ s/=f$/ [n.n]/;
      printf STDERR "  --%-15s %s%s\n", $opt, $_->{DESC}, $def;
    }
    else {
      print STDERR "$_\n";
    }      
  }
  exit(1);
}

#----------------------------------------------------------------------

