#!/usr/bin/env perl
use warnings;
use strict;
use Data::Dumper;
use Bio::Tools::GFF;
use Fatal;

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Command line checking

my(@Options, $debug, $auto, $vcf, $ref, $bam, $gff);
setOptions();

if ($auto) {
  $vcf ||= 'snps.vcf';
  $ref ||= 'ref.fa';
  $bam ||= 'aln.bam';
  $gff ||= 'ref.gff';
}

$vcf or die "need --vcf <snps.vcf>";
$ref or die "need --ref <reference.fa>";
$bam or die "need --bam <alignments.bam>";

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Create an index of seq:pos => feature

my %feat;
my %olap;
my $nfeat=0;
if ($gff) {
  print STDERR "Loading features: $gff\n";
  my $in = Bio::Tools::GFF->new(-file=>$gff, -gff_version=>3);
  while (my $f = $in->next_feature) {
    $feat{++$nfeat} = $f;
    for my $pos ($f->start .. $f->end) {
      $olap{$f->seq_id}->[$pos] = $nfeat;  # FIXME: should be push()
    }
  }
}

# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
# Create a SNP table file

#my %type_of = (0=>'snp', -1=>'ins', +1=>'del');

my $count=0;
print join("\t", qw(CHROM POS TYPE REF ALT EVIDENCE FEATURES)),"\n";

print STDERR "Using reference: $ref\n";
print STDERR "Using alignements: $bam\n";
print STDERR "Parsing variants: $vcf\n";
open VCF, '<', $vcf;
while (<VCF>) {
  next if m/^#/;
  chomp;

  # [VCF] CHROM POS ID REF ALT QUAL FILTER INFO [FORMAT DATA DATA2 ...]
  my($chr,$pos,undef,$ref,$alt,undef,undef,$tags) = split m/\t/;
  my $tag = vcf_tags_to_hash($tags);

  my $aff = '';
  my $aff_featid = $olap{ $chr }[ $pos ]; 
  if ($aff_featid) {
    my $f = $feat{$aff_featid};
    $aff = join(' ', $f->primary_tag, 
      map { $f->get_tag_values($_) if $f->has_tag($_) } qw(locus_tag gene product) )   
  }
  my @evid;
  # freebayes VCF seems to use different tags when TYPE=indel ...
  my $RO = $tag->{RO} || '0';
  my $AO = $tag->{AO} || '0';  
  push @evid, "$ref:$RO", "$alt:$AO";
  push @evid, "N=".$tag->{DP} if $debug;
  my $evid = join(' ', @evid);

  print join("\t", $chr, $pos, $tag->{TYPE}, $ref, $alt, $evid, $aff),"\n";
  $count++;  
}
print STDERR "Converted $count SNPs to TSV format.\n";

#----------------------------------------------------------------------
# name1=tag1;name2;name3=tag3 => HASH

sub vcf_tags_to_hash {
  my($s) = @_;
  my @pairs = split m/;/, $s;
  my %tag;
  for my $p (@pairs) {
    my @x = split m/=/, $p;
    $tag{$x[0]} = $x[1];  # will be =>undef for bareword tags eg. INDEL;
  }
  return \%tag;
}

#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    {OPT=>"help!",     VAR=>\&usage,                DESC=>"This help"},
    {OPT=>"debug!",    VAR=>\$debug,   DEFAULT=>0,  DESC=>"Output verbose debug info"},
    {OPT=>"auto!",     VAR=>\$auto,    DEFAULT=>0 , DESC=>"Autoset --vcf/bam/ref/gff to snippy names"},
    {OPT=>"vcf=s",     VAR=>\$vcf,     DEFAULT=>'', DESC=>"VCF input file"},
    {OPT=>"bam=s",     VAR=>\$bam,     DEFAULT=>'', DESC=>"BAM alignment"},
    {OPT=>"ref=s",     VAR=>\$ref,     DEFAULT=>'', DESC=>"FASTA reference sequence"},
    {OPT=>"gff=s",     VAR=>\$gff,     DEFAULT=>'', DESC=>"GFF reference features"},
  );

  (!@ARGV) && (usage());

  &GetOptions(map {$_->{OPT}, $_->{VAR}} @Options) || usage();

  # Now setup default values.
  foreach (@Options) {
    if (defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

sub usage {
  print STDERR "Synopsis:\n  Convert a VCF (haploid) into TSV with column breakdown\n";
  print STDERR "Usage:\n  $0 [options] --vcf snps.vcf --bam aln.bam --ref ref.fa > snps.csv\n";
  print STDERR "Options:\n";
  foreach (@Options) {
    printf STDERR "  --%-13s %s%s.\n",$_->{OPT},$_->{DESC},
                  defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
  }
  exit(1);
}
 
#----------------------------------------------------------------------
